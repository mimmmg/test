#include <stdio.h>
int main(){
    double num = 0.01;
    double res = 0;
    int cnt = 0;
    while(cnt < 100)
    {
        res += num;
        cnt++;
    }
    printf(res == 1 ? "true" : "false");

    return 0;
}

//이 C 프로그램은 부동소수점 연산의 정밀도 문제를 보여주는 예제입니다. 주요 내용은 다음과 같습니다:

//num이라는 변수에 0.01을 저장합니다.
//res라는 변수를 0으로 초기화합니다.
//cnt라는 카운터 변수를 0으로 초기화합니다.
//while 루프를 사용해 다음 작업을 100번 반복합니다:

//res에 num(0.01)을 더합니다.
//cnt를 1 증가시킵니다.

//이론적으로, 0.01을 100번 더하면 정확히 1이 되어야 합니다.
//마지막으로, res가 1과 정확히 같은지 비교하여 결과를 출력합니다.

//같다면 "true"를, 다르다면 "false"를 출력합니다.

//이 프로그램의 핵심은 부동소수점 연산의 한계를 보여주는 것입니다. 
//컴퓨터에서 부동소수점 숫자는 이진수로 표현되는데, 0.01 같은 십진 소수는 이진수로 정확히 표현할 수 없습니다. 
//따라서 작은 오차가 누적되어, 최종 결과가 정확히 1이 되지 않을 수 있습니다.
//이로 인해 프로그램은 대부분의 경우 "false"를 출력할 것입니다. 
//이는 부동소수점 연산에서 정확성을 요구하는 경우 주의해야 함을 보여주는 좋은 예시입니다.