#include <stdio.h>
int main() {
    int n1 = 172;
    int n2 = 387;

    while( n1 !=n2 )  //!는 not이라는 의미 따라서 n1과 n2가 같지않으면 계속돌리라는 while 반복문
    {
        if ( n1 > n2 ) n1-=n2;  //n1=n1-n2
        else n2-=n1;            //n2=n2-n1
    }

    printf("%d", n1);

    return 0;
}

//while 루프는 n1과 n2가 서로 다른 동안 계속 실행됩니다.
//루프 내부에서:

//n1이 n2보다 크면, n1에서 n2를 뺍니다.
//그렇지 않으면 (즉, n2가 n1보다 크거나 같으면), n2에서 n1을 뺍니다.


//루프가 종료되면 n1의 값을 출력합니다.

//해석:

//이 알고리즘은 사실 유클리드 알고리즘의 변형으로, 두 수의 최대공약수(GCD)를 구하는 방법입니다.
//과정을 단계별로 보면:

//387 - 172 = 215 (n2 = 215)
//215 - 172 = 43 (n2 = 43)
//172 - 43 = 129 (n1 = 129)
//129 - 43 = 86 (n1 = 86)
//86 - 43 = 43 (n1 = 43)
//이 시점에서 n1 == n2 이므로 루프 종료


//결과적으로 172와 387의 최대공약수인 43이 출력됩니다.

//이 알고리즘의 원리:

//두 수 A와 B의 최대공약수는 A와 (A를 B로 나눈 나머지)의 최대공약수와 같습니다.
//이 과정을 반복하면 결국 두 수가 같아지는 시점이 오는데, 이 때의 값이 최대공약수입니다.

//이 코드는 뺄셈을 사용하여 이 원리를 구현한 것으로, 효율적인 최대공약수 계산 방법을 보여주는 좋은 예시입니다.